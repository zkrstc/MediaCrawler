# 补全截图工具使用说明

## 🎯 问题场景

### **问题描述**

```
第一次运行：
  笔记A：layer_0.png, layer_1.png, layer_2.png 【中断】
  
第二次运行（旧逻辑）：
  笔记B：layer_3.png, layer_4.png... ❌ 错误！
  
问题：
  - 临时文件没有区分笔记ID
  - 不同笔记的截图混在一起
  - 无法准确判断哪个笔记不完整
```

---

## ✅ 解决方案

### **1. 修复临时文件隔离（已完成）**

**改进**：每个笔记的临时文件保存在独立目录

```
旧结构：
data/xhs/screenshots/temp/
  ├── layer_0.png  ❌ 不知道是哪个笔记的
  ├── layer_1.png
  └── layer_2.png

新结构：
data/xhs/screenshots/temp/
  ├── 65e159e5/  ✅ 笔记A的临时文件
  │   ├── layer_1_65e159e5.png
  │   ├── layer_2_65e159e5.png
  │   └── layer_3_65e159e5.png
  └── 6885ead5/  ✅ 笔记B的临时文件
      ├── layer_1_6885ead5.png
      └── layer_2_6885ead5.png
```

**效果**：
- ✅ 每个笔记独立目录
- ✅ 文件名包含笔记ID
- ✅ 开始截图前自动清理旧文件
- ✅ 准确识别每个笔记的截图层数

---

### **2. 补全截图工具（新增）**

**独立工具**：`tools/complete_screenshots.py`

**功能**：
1. 检查所有笔记的截图完整性
2. 列出需要重新截图的笔记
3. 自动为不完整的笔记补全截图

---

## 📊 使用方法

### **方法1：自动续爬（推荐）**

直接运行主程序，会自动检测并补全：

```bash
python main.py
```

**日志示例**：
```
[CrawlProgressManager] Note 65e159e5 has incomplete screenshot (3 layers < 20)
[CrawlProgressManager] Found 1 notes with incomplete screenshots
  - 1 notes have incomplete screenshots (will be re-captured)

[XiaoHongShuCrawler.search] 📸 Found 1 notes with complete comments but missing screenshots
[XiaoHongShuCrawler.batch_screenshot_comments] Begin batch screenshot for 1 notes
[XiaoHongShuCrawler.batch_screenshot_comments] Screenshotting note 65e159e5

[screenshot_comments_section] Starting layer-by-layer screenshot (target: 20 comments)
[screenshot_comments_section] Processing layer 1...
[screenshot_comments_section] Processing layer 2...
...
[screenshot_comments_section] Processing layer 20...
[screenshot_comments_section] Successfully captured 20 layers, now stitching...
```

---

### **方法2：使用补全工具（独立运行）**

如果只想补全截图，不想重新爬取：

```bash
python tools/complete_screenshots.py
```

**执行流程**：

```
1. 检查阶段
   ============================================================
   [CompleteScreenshots] Screenshot Completion Tool
   ============================================================
   [CompleteScreenshots] Checking screenshot completeness...
   
   [CompleteScreenshots] Note 65e159e5: incomplete screenshot (3/20 layers)
   [CompleteScreenshots] Note 6885ead5: no screenshot (comments: 20/20)

2. 统计阶段
   [CompleteScreenshots] Summary:
     - Total notes need screenshot: 2
     - No screenshot: 1
     - Incomplete screenshot: 1
       - 65e159e5: 3/20 layers

3. 确认阶段
   ============================================================
   Do you want to complete these screenshots? (y/n): y

4. 执行阶段
   [CompleteScreenshots] Starting to complete screenshots...
   [CompleteScreenshots] (1/2) Processing note 65e159e5
     - Comments: 20
     - Current layers: 3
     - Target layers: 20
   
   [screenshot_comments_section] Starting layer-by-layer screenshot (target: 20 comments)
   [screenshot_comments_section] Processing layer 1...
   ...
   [screenshot_comments_section] Processing layer 20...
   
   [CompleteScreenshots] ✓ Screenshot completed: comments_65e159e5_1729134000.png
   
   [CompleteScreenshots] (2/2) Processing note 6885ead5
   ...
   
   [CompleteScreenshots] Completed! Processed 2 notes
```

---

## 🔍 检查标准

### **完整截图的判断**

```python
完整 = 一级评论数量 >= 20 
       + 最终截图存在 
       + (临时层文件 == 0 或 临时层文件 >= 20)

不完整 = 一级评论数量 >= 20 
         + 最终截图不存在 
         + 临时层文件 < 20
```

### **检查逻辑**

```python
for note_id in all_notes:
    # 1. 检查最终截图
    if comments_{note_id}_*.png 存在:
        ✅ 完整，跳过
    
    # 2. 检查评论数量
    if 一级评论数量 < 20:
        ⚠️ 评论不完整，跳过（需要重新爬取评论）
    
    # 3. 检查临时层文件
    temp_dir = data/xhs/screenshots/temp/{note_id}/
    layer_count = len(layer_*.png)
    
    if layer_count == 0:
        📸 无截图，需要截图
    elif layer_count < 20:
        📸 截图不完整（{layer_count}/20层），需要重新截图
    else:
        ✅ 临时文件完整，可能拼接失败，需要重新拼接
```

---

## 📂 文件结构

```
data/xhs/
├── csv/
│   ├── search_contents_2025-10-17.csv  # 笔记详情
│   └── search_comments_2025-10-17.csv  # 评论数据
└── screenshots/
    ├── comments_65e159e5_1729134000.png  # 最终截图（完整）
    ├── comments_6885ead5_1729134100.png  # 最终截图（完整）
    └── temp/  # 临时文件（按笔记ID隔离）
        ├── 65e159e5/  # 笔记A的临时文件
        │   ├── layer_1_65e159e5.png
        │   ├── layer_2_65e159e5.png
        │   └── ...
        └── 6885ead5/  # 笔记B的临时文件
            ├── layer_1_6885ead5.png
            └── layer_2_6885ead5.png
```

---

## 🎯 使用场景

### **场景1：截图中断**

```
第一次运行：
  笔记A：截图到第3层 【中断】

第二次运行：
  自动检测：笔记A有3层临时文件 < 20层
  自动处理：重新截图笔记A（20层）
```

---

### **场景2：拼接失败**

```
第一次运行：
  笔记A：截图20层完成 ✅
  拼接长图：失败 ❌

第二次运行：
  自动检测：笔记A有20层临时文件 = 20层
  自动处理：重新拼接（不重新截图）
```

---

### **场景3：只想补全截图**

```
情况：
  - 评论已经爬取完整
  - 但截图缺失或不完整
  - 不想重新运行整个爬虫

解决：
  python tools/complete_screenshots.py
  
  只补全截图，不重新爬取评论
```

---

## ⚙️ 配置说明

```python
# config.py

# 一级评论数量（决定截图层数）
CRAWLER_MAX_COMMENTS_COUNT_SINGLENOTES = 20

# 截图上限（应该与一级评论数量一致）
SCREENSHOT_COMMENTS_COUNT = 20

# 启用续爬
ENABLE_RESUME_CRAWL = True

# 启用评论截图
ENABLE_GET_COMMENTS_SCREENSHOT = True

# 爬取间隔
CRAWLER_MAX_SLEEP_SEC = 10
```

---

## 🚨 注意事项

### **1. 临时文件清理**

每次开始截图前，会自动清理该笔记的旧临时文件：

```python
# 清理逻辑
if os.path.exists(temp_dir):
    for old_file in os.listdir(temp_dir):
        if old_file.startswith('layer_') and old_file.endswith('.png'):
            os.remove(old_file)
```

**目的**：避免旧文件干扰新截图。

---

### **2. 文件名格式**

```
临时文件：layer_{序号}_{note_id}.png
  - layer_1_65e159e5.png
  - layer_2_65e159e5.png

最终文件：comments_{note_id}_{timestamp}.png
  - comments_65e159e5_1729134000.png
```

---

### **3. 并发处理**

补全工具是**串行处理**（一个一个截图），避免浏览器资源冲突。

如果想并发，建议使用主程序的 `MAX_CONCURRENCY_NUM` 配置。

---

## ✅ 总结

**修复内容**：

1. ✅ **临时文件隔离**
   - 每个笔记独立目录
   - 文件名包含笔记ID
   - 开始前自动清理旧文件

2. ✅ **精确检查**
   - 按笔记ID检查层数
   - 准确识别不完整的笔记
   - 不会混淆不同笔记的截图

3. ✅ **补全工具**
   - 独立运行，不影响主程序
   - 只补全截图，不重新爬取评论
   - 交互式确认，避免误操作

**现在可以放心爬取了！** 🎉

- 截图不会混乱
- 中断后会自动续爬
- 可以单独补全截图
