# 常见问题解决方案

## 🔍 问题1：content.csv 有重复记录

### **问题描述**
第二次运行时，`content.csv` 中出现重复的笔记记录。

### **原因分析**
```
第一次运行：
  保存笔记A到 content.csv ✅
  内存记录：saved_note_ids = {A}
  
程序重启：
  内存清空：saved_note_ids = {}  ❌
  
第二次运行：
  保存笔记A到 content.csv（因为内存中没有记录）
  结果：重复记录 ❌
```

### **解决方案** ✅

已修复！现在启动时会自动加载已有的笔记ID：

```python
# store/xhs/_store_impl.py
def __init__(self):
    self.saved_note_ids = set()
    self._load_existing_note_ids()  # 从CSV加载已有ID

def _load_existing_note_ids(self):
    # 读取 content.csv
    # 加载所有已保存的 note_id
    # 避免重复写入
```

**效果**：
```
第二次运行：
  启动时加载：saved_note_ids = {A, B, C, ...}
  尝试保存笔记A：检测到已存在 → 跳过 ✅
  不会重复写入 ✅
```

---

## 🔍 问题2：评论和截图的执行顺序

### **问题描述**
"我发现是先爬取所有的评论然后再截图的"

### **实际情况**

**不是这样的！** 实际是**逐个笔记**处理：

```python
# 对每个笔记：
for note in notes:
    1. 爬取该笔记的评论
    2. 立即截图该笔记的评论区
    3. 保存截图路径
    4. 处理下一个笔记
```

### **详细流程**

```
笔记A：
  ↓
  爬取10条一级评论 + 二级评论
  ↓
  逐层截图（10层）
  ↓
  拼接成长图
  ↓
  保存截图路径
  ↓
笔记B：
  ↓
  爬取10条一级评论 + 二级评论
  ↓
  逐层截图（10层）
  ↓
  拼接成长图
  ↓
  保存截图路径
```

### **为什么看起来像"先爬所有评论"？**

可能是因为日志输出的顺序：

```
[爬取评论] 笔记A
[爬取评论] 笔记B
[截图] 笔记A
[截图] 笔记B
```

但实际上是**并发处理**（如果 `MAX_CONCURRENCY_NUM > 1`）。

---

## 🔍 问题3：截图中断后无法续爬

### **问题描述**
第一次运行时截图中断，第二次运行没有继续截图。

### **原因分析**

```
第一次运行：
  笔记A：评论完整 ✅ + 截图到第3层【中断】❌
  
comments.csv: 笔记A的10条一级评论 ✅
截图文件: 无（拼接未完成）❌

第二次运行（旧逻辑）：
  检查：一级评论10条 >= 10 ✅
  判定：已完成 → 跳过 ❌
  结果：没有截图 ❌
```

### **解决方案** ✅

已修复！现在会检查截图文件是否存在：

```python
# tools/crawl_progress.py
def load_crawled_comment_note_ids(self, check_screenshot=True):
    # 检查一级评论数量
    if primary_count >= 10:
        # 检查截图文件是否存在
        if check_screenshot and ENABLE_GET_COMMENTS_SCREENSHOT:
            if not screenshot_exists:
                # 评论完整但截图缺失 → 重新爬取
                return False
    return True
```

**效果**：
```
第二次运行（新逻辑）：
  检查：
    - 一级评论：10条 >= 10 ✅
    - 截图文件：不存在 ❌
  判定：不完整 → 重新爬取 ✅
  重新爬取并截图 ✅
```

---

## 🎯 完整的续爬机制

### **三层检查**

```
1. Content 续爬
   检查：content.csv 中是否有该笔记
   跳过：已爬取的笔记详情

2. Comment 续爬
   检查：comments.csv 中一级评论数量
   跳过：一级评论 >= 目标数量

3. Screenshot 续爬（新增）⭐
   检查：截图文件是否存在
   跳过：评论完整 + 截图存在
```

### **判断标准**

```python
完整 = Content ✅ + Comment ✅ + Screenshot ✅

Content ✅: 笔记在 content.csv 中
Comment ✅: 一级评论数量 >= CRAWLER_MAX_COMMENTS_COUNT_SINGLENOTES
Screenshot ✅: 存在 comments_{note_id}_*.png 文件
```

---

## 📊 日志示例

### **启动时**

```
[XhsCsvStoreImplement] Loaded 50 existing note IDs from content.csv

[CrawlProgressManager] Found 3 notes with complete comments but missing screenshots
  - These notes will be re-crawled to generate screenshots

[CrawlProgressManager] Comment crawl status:
  - Complete notes (>=20 primary comments + screenshot): 45
  - Incomplete notes (<20 primary comments): 2
```

**解读**：
- 加载了50个已保存的笔记ID（避免重复）
- 3个笔记：评论完整但截图缺失（会重新爬取）
- 45个笔记：完全完整（跳过）
- 2个笔记：评论不完整（清理并重新爬取）

---

## ⚙️ 配置建议

```python
# config.py

# 爬取数量
CRAWLER_MAX_NOTES_COUNT = 30

# 一级评论数量（决定截图层数）
CRAWLER_MAX_COMMENTS_COUNT_SINGLENOTES = 20

# 截图上限（应该 >= 一级评论数量）
SCREENSHOT_COMMENTS_COUNT = 20  # 或设置为0表示截取所有

# 启用续爬
ENABLE_RESUME_CRAWL = True

# 自动清理不完整的评论
ENABLE_AUTO_CLEAN_INCOMPLETE_COMMENTS = True

# 启用评论截图
ENABLE_GET_COMMENTS_SCREENSHOT = True
```

---

## 🚨 注意事项

### **1. 截图层数由爬取数量决定**

```python
实际截图层数 = min(
    CRAWLER_MAX_COMMENTS_COUNT_SINGLENOTES,  # 实际爬取的一级评论数
    SCREENSHOT_COMMENTS_COUNT                 # 截图上限
)
```

**建议**：两个配置保持一致。

### **2. 并发数量影响日志顺序**

```python
MAX_CONCURRENCY_NUM = 1  # 串行处理，日志清晰
MAX_CONCURRENCY_NUM = 3  # 并发处理，日志可能交错
```

### **3. 临时文件保留**

截图的临时文件（`temp/layer_*.png`）默认保留，用于调试。

如果不需要，可以手动删除：
```bash
rm -rf data/xhs/screenshots/temp/
```

---

## ✅ 总结

**已修复的问题**：
1. ✅ content.csv 重复记录 → 启动时加载已有ID
2. ✅ 截图中断无法续爬 → 检查截图文件存在性
3. ✅ 评论完整性检查 → 只统计一级评论数量

**续爬机制**：
- Content 续爬：跳过已爬取的笔记
- Comment 续爬：跳过评论完整的笔记
- Screenshot 续爬：跳过有截图的笔记

**现在可以放心爬取了！** 🎉
